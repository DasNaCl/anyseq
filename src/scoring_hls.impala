
static READ_TOP_ROW_FLAG     = 1 << 0;

struct InitScoresAcc {
  read:  fn(Index) -> Score,
  write: fn(Index, Score) -> (),

  read_top_row:      fn(Index) -> Score,
  write_top_row:     fn(Index, Score) -> (),

  matches: MatchFn
}
fn @get_init_scores_acc(read: fn(Index) -> Score, write: fn(Index, Score) -> (), sc: ScoringScheme) -> InitScoresAcc{
    // we trick a bit by ignoring the argument functions (the PS provides init scores to PL, which we aren't modeling)
    let acc = accelerator(device_id);
    let left_column = acc.alloc(5 * sizeof[Score]());
    let top_row = acc.alloc(7 * sizeof[Score]());
    
    InitScoresAcc{
      read:  |i|   bitcast[&[1][Score]](left_column.data)(i),
      write: |i,v| bitcast[&mut[1][Score]](left_column.data)(i) = v,

      read_top_row:      |i|   bitcast[&[1][Score]](top_row.data)(i),
      write_top_row:     |i,v| bitcast[&mut[1][Score]](top_row.data)(i) = v,

      matches: sc.matches
    }
}
fn @get_global_scoring_linmem(height: Index, width: Index, scheme: AlignmentScheme) -> Scoring{
    let score_matrix = create_scoring_matrix_linmem(height, width, scheme.init_scores,
                                                    READ_TOP_ROW_FLAG);
    create_scoring(score_matrix, || undef[Score](), || undef[(Index, Index)]())
}

fn @get_semiglobal_scoring_linmem(height: Index, width: Index, scheme: AlignmentScheme) -> Scoring{
    // the last row corresponds to the state a pe i is in after `subject_len + i` steps
    // the last column corresponds to the stuff that was written to left_column (aka init_scores)
    // We might be able to find the store using this information.

    let score_matrix = create_scoring_matrix_linmem(height, width, scheme.init_scores, 0);
    let maxs = create_maximums_array(PE_COUNT);

    let semiglobal_score_matrix = ScoringMatrix{
        get_iteration_acc:     get_semiglobal_linmem_iteration_acc_device(score_matrix, maxs, scheme.init_scores),
        get_matrix:            score_matrix.get_matrix,
        get_last_row:          score_matrix.get_last_row,
        get_last_column:       score_matrix.get_last_column,
        get_right_half_column: score_matrix.get_last_column,
        release:               score_matrix.release
    };

    Scoring{
        get_scoring_matrix:   || semiglobal_score_matrix,
        get_score:            || undef[Score](),
        get_score_pos:        || undef[(Index, Index)](),
        get_left_half_scores:    semiglobal_score_matrix.get_last_column,
        get_right_half_scores:   semiglobal_score_matrix.get_right_half_column,
        release:              || ()
    }
}

struct MaximumsArray {
  get_maxij_old: fn(Index) -> Score,
  get_imaxi_1j: fn(Index) -> Score,
  
  write_maxij_old: fn(Index, Score) -> (),
  write_imaxi_1j: fn(Index, Score) -> (),
};
fn @create_maximums_array(size: i32) -> MaximumsArray{
  let maxij_old = create_data_vector(size, SCORE_MIN_VALUE as Score);
  let imaxi_1j = create_data_vector(size, SCORE_MIN_VALUE as Score);

  MaximumsArray {
    get_maxij_old: maxij_old.read,
    get_imaxi_1j:  imaxi_1j.read,
    
    write_maxij_old: maxij_old.write,
    write_imaxi_1j:  imaxi_1j.write,
  }
}

fn @get_local_scoring_linmem(height: Index, width: Index, scheme: AlignmentScheme) -> Scoring{
    let score_matrix = create_scoring_matrix_linmem(height, width, scheme.init_scores, 0);
    let maxs = create_maximums_array(PE_COUNT);

    let local_score_matrix = ScoringMatrix{
        get_iteration_acc:     get_local_linmem_iteration_acc_device(score_matrix, maxs, scheme.init_scores),
        get_matrix:            score_matrix.get_matrix,
        get_last_row:          score_matrix.get_last_row,
        get_last_column:       score_matrix.get_last_column,
        get_right_half_column: score_matrix.get_last_column,
        release:               score_matrix.release
    };

    Scoring{
        get_scoring_matrix:   || local_score_matrix,
        get_score:            || undef[Score](),
        get_score_pos:        || undef[(Index, Index)](),
        get_left_half_scores:    local_score_matrix.get_last_column,
        get_right_half_scores:   local_score_matrix.get_right_half_column,
        release:              || ()
    }
}
struct ScoringArray {
  // Inputs
  get_ihi_1j: fn(Index) -> Score,
  write_ihi_1j: fn(Index, Score) -> (),

  // Score
  get_hi_1j_1_old: fn(Index) -> Score,
  get_hij_1_old: fn(Index) -> Score,

  write_hi_1j_1_old: fn(Index, Score) -> (),
  write_hij_1_old: fn(Index, Score) -> (),

  get_degenerate: fn(Index) -> i8,
  write_degenerate: fn(Index, i8) -> ()
};
fn @create_scoring_array(size: i32) -> ScoringArray {
  let ihi_1j = create_data_vector(size, 0 as Score);

  let hi_1j_1_old = create_data_vector(size, 0 as Score);
  let hij_1_old = create_data_vector(size, 0 as Score);

  let degenerate = create_data_vector(size, 0 as Score);

  ScoringArray {
    get_ihi_1j:        ihi_1j.read,
    write_ihi_1j:      ihi_1j.write,

    get_hi_1j_1_old:   hi_1j_1_old.read,
    get_hij_1_old:     hij_1_old.read,

    write_hi_1j_1_old: hi_1j_1_old.write,
    write_hij_1_old:   hij_1_old.write,

    get_degenerate:    @|i| degenerate.read(i) as i8,
    write_degenerate:  @|i,v| degenerate.write(i, v as Score)
  }
}

fn create_scoring_matrix_linmem(height: Index, width: Index, olddata: InitScoresAcc, @read_mask: i32) -> ScoringMatrix{
    let pe_scoring = create_scoring_array(PE_COUNT);
    
    if(read_mask & READ_TOP_ROW_FLAG == READ_TOP_ROW_FLAG) {
      let mut top_cur = olddata.read_top_row(0);
      for pe in range(0, PE_COUNT) {
        let top_next = olddata.read_top_row(pe + 1);
        pe_scoring.write_hi_1j_1_old(pe, top_cur);
        pe_scoring.write_hij_1_old(pe, top_next);
        top_cur = top_next;
      }
    } else {
      for pe in range(0, PE_COUNT) {
        pe_scoring.write_hi_1j_1_old(pe, 0 as Score);
        pe_scoring.write_hij_1_old(pe, 0 as Score);
      }
    }
    ScoringMatrix{
        get_iteration_acc:        get_linmem_iteration_acc_device(pe_scoring, olddata),
        get_matrix:            || undef[Matrix](),
        get_last_row:          || undef[Vector](),
        get_last_column:       || undef[Vector](),
        get_right_half_column: || undef[Vector](),
        release:               || ()
    }
}

fn get_linmem_iteration_acc_device(pe_line: ScoringArray, olddata: InitScoresAcc) -> fn(Index, Index, Index, Index, bool, IterationInfo) -> ScoringMatrixAcc{
    |offset_i, offset_j, height, width, _, it| -> ScoringMatrixAcc{
        ScoringMatrixAcc{
            read_no_gap:       |i, _| { pe_line.get_hi_1j_1_old(i) },
            read_gap_q:        |i, _| { pe_line.get_hij_1_old(i) },
            read_gap_s:        |i, _| { pe_line.get_ihi_1j(i) },
            write:             |i, j, hij| {
                  if(pe_line.get_degenerate(i) == 0 as i8) {
                      if(j >= i) {
                        pe_line.write_hi_1j_1_old(i, pe_line.get_ihi_1j(i));
                      }
                      if(it.get_iai() != 4/*SBT_COL_SIZE*/ as SequenceElem) {
                        pe_line.write_hij_1_old(i, hij);
                      }
                      else {
                        pe_line.write_hij_1_old(i, pe_line.get_hij_1_old(i));
                      }
                  }
                  else {
                      pe_line.write_hij_1_old(i, pe_line.get_ihi_1j(i));
                  }
              },
            update_write:      @|i| {
                  pe_line.write_ihi_1j(i + 1, pe_line.get_hij_1_old(i));
              },
            update_begin_line: @(?k)|k,i|{
                  if(k == 1) {
                      pe_line.write_ihi_1j(0, 0 as Score);
                  }
                  else {
                      let tmp = olddata.read(i);
                      pe_line.write_ihi_1j(0, tmp as Score);
                  }
              },
            update_end_line:   |bufoff|{
                  let hij_1_old = pe_line.get_hij_1_old(PE_COUNT - 1);
                  olddata.write(bufoff, hij_1_old);
              },
            block_begin:       |ql,q_acc| {
                //readQuery
                for pe in range(0, PE_COUNT){
                    if(pe < ql) {
                      pe_line.write_degenerate(pe, 0 as i8);
                    }
                    else {
                      pe_line.write_degenerate(pe, 1 as i8);
                    }
                    pe_line.write_ihi_1j(pe,   0 as Score);
                }
            },
            block_end:         || {
                it.write_result(pe_line.get_hij_1_old(PE_COUNT - 1));
            }
        }
    }
}

fn @get_local_max_vector_size_device(matrix_width: Index) -> Index { matrix_width }

fn get_local_linmem_iteration_acc_device(score_matrix: ScoringMatrix, max_scores: MaximumsArray, olddata: InitScoresAcc) -> fn(Index, Index, Index, Index, bool, IterationInfo) -> ScoringMatrixAcc{
    |offset_i, offset_j, height, width, is_left_half, it| {
        let mat_acc = score_matrix.get_iteration_acc(offset_i, offset_j, height, width, is_left_half, it);

        ScoringMatrixAcc{
            read_no_gap:       mat_acc.read_no_gap,
            read_gap_q:        mat_acc.read_gap_q,
            read_gap_s:        mat_acc.read_gap_s,
            write:             |i,j,hij| {
                mat_acc.write(i, j, hij);
                let maxij = max(hij, max(max_scores.get_imaxi_1j(i), max_scores.get_maxij_old(i)));
                max_scores.write_maxij_old(i, maxij);
            },
            update_write:      |i| {
                mat_acc.update_write(i);
                if(i + 1 < PE_COUNT) {
                    max_scores.write_imaxi_1j(i + 1, max_scores.get_maxij_old(i));
                }
            },
            update_begin_line: @(?k)|k,i| {
                mat_acc.update_begin_line(k, i);
                if(k == 1) {
                    max_scores.write_imaxi_1j(0, 0 as Score);
                }
                else {
                    let tmp = olddata.read(i);
                    max_scores.write_imaxi_1j(0, tmp as Score);
                }
            },
            update_end_line:   mat_acc.update_end_line,
            block_begin:       |a,b| {
                mat_acc.block_begin(a,b);
                for pe in range(0, PE_COUNT) {
                  max_scores.write_imaxi_1j(pe, 0 as Score);
                  max_scores.write_maxij_old(pe, 0 as Score);
                }
            },
            block_end:         || {
                it.write_result(max_scores.get_maxij_old(PE_COUNT - 1));
            }
        }
    }
}


fn get_semiglobal_linmem_iteration_acc_device(score_matrix: ScoringMatrix, max_scores: MaximumsArray, olddata: InitScoresAcc) -> fn(Index, Index, Index, Index, bool, IterationInfo) -> ScoringMatrixAcc{
    |offset_i, offset_j, height, width, is_left_half, it| {
        let mat_acc = score_matrix.get_iteration_acc(offset_i, offset_j, height, width, is_left_half, it);

        ScoringMatrixAcc{
            read_no_gap:       mat_acc.read_no_gap,
            read_gap_q:        mat_acc.read_gap_q,
            read_gap_s:        mat_acc.read_gap_s,
            write:             |i,j,hij| {
                mat_acc.write(i, j, hij);

                let is_bottom = j - i >= it.subject_len;
                /// rightmost column maximization must happen on PS!!
                //let is_right  = i == PE_COUNT - 1 && j >= PE_COUNT - 1;
                if(is_bottom) {
                  let maxij = max(hij, max(max_scores.get_imaxi_1j(i), max_scores.get_maxij_old(i)));
                  max_scores.write_maxij_old(i, maxij);
                }
            },
            update_write:      |i| {
                mat_acc.update_write(i);
                if(i + 1 < PE_COUNT) {
                    max_scores.write_imaxi_1j(i + 1, max_scores.get_maxij_old(i));
                }
            },
            update_begin_line: @(?k)|k,i| {
                mat_acc.update_begin_line(k, i);
                if(k == 1) {
                    max_scores.write_imaxi_1j(0, 0 as Score);
                }
                else {
                    let tmp = olddata.read(i);
                    max_scores.write_imaxi_1j(0, tmp as Score);
                }
            },
            update_end_line:   mat_acc.update_end_line,
            block_begin:       |a,b| {
                mat_acc.block_begin(a,b);
                for pe in range(0, PE_COUNT) {
                  max_scores.write_imaxi_1j(pe, 0 as Score);
                  max_scores.write_maxij_old(pe, 0 as Score);
                }
            },
            block_end:         || {
                it.write_result(max_scores.get_maxij_old(PE_COUNT - 1));
            }
        }
    }
}

fn get_iteration_acc_hb_device(column_left: Vector, column_right: Vector, row: Vector, corners: Vector, block_width: Index) -> fn(Index, Index, Index, Index, bool, IterationInfo) -> ScoringMatrixAcc{
    print_string("UNSUPPORTED: get_iteration_acc_hb_device");

    undef[fn(Index, Index, Index, Index, bool, IterationInfo) -> ScoringMatrixAcc]()
}

fn get_iteration_acc_tb_device(block_width: Index, init_scores: InitScoresAcc) -> fn(Index, Index, Index, Index, bool, IterationInfo) -> ScoringMatrixAcc{
    print_string("UNSUPPORTED: get_iteration_acc_tb_device");

    undef[fn(Index, Index, Index, Index, bool, IterationInfo) -> ScoringMatrixAcc]()
}

