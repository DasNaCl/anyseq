
static BLOCK_WIDTH = PE_COUNT;
static BLOCK_HEIGHT = 1;

struct IterationInfo {
  get_iai: fn() -> SequenceElem,
  write_iai: fn(SequenceElem) -> (),
  write_result: fn(Score) -> (),

  subject_len: i32
}

fn @create_iteration_info(result: Buffer, s_len: i32) -> IterationInfo {
    let mut iai_cpy = 4 as SequenceElem;
    IterationInfo{
      get_iai:   @|| iai_cpy,
      write_iai: @|v| iai_cpy = v,
      
      write_result: @|v| bitcast[&mut[1][Score]](result.data)(0) = v,

      subject_len: s_len      
    }
}

fn @iteration(query_p: Sequence, subject_p: Sequence, fakescores: ScoringMatrix, predc: PredecessorMatrix, scheme: AlignmentScheme, body: RelaxationBody) -> ()
{

    let acc = accelerator(device_id);

    // subjectt will contain a subject sequence letter and a column cell score
    //   subjectt[i] = sub_seq[i] << 16U | (left_col[i] & 0xFFFF);
    let subjectt = acc.alloc(1 * sizeof[i32]());
    let subject_lenn = acc.alloc(2 * sizeof[Index]());
    let querytt = acc.alloc(3 * sizeof[SequenceElem]());
    let querytt_lenn = acc.alloc(4 * sizeof[Index]());
    let resultt = acc.alloc(6 * sizeof[Score]());

    fn seq_reader(seq: Buffer, len: Index) -> ReadSequenceFn{
      |i| if i >= len { 4 as SequenceElem } else { bitcast[&[1][SequenceElem]](seq.data)(i) }
    }
    fn seq_writer(seq: Buffer, len: Index) -> WriteSequenceFn{
      |i,v| if i >= len { () } else { bitcast[&mut[1][SequenceElem]](seq.data)(i) = v }
    }

    for work_item in acc.exec((1,1,1), (1,1,1)) {

        let scoring = scheme.get_scoring(0, 0, scheme);
        let scores = scoring.get_scoring_matrix();

        let query_len = bitcast[&[1][Index]](querytt_lenn.data)(0);
        let subject_len = bitcast[&[1][Index]](subject_lenn.data)(0);

        let itinf = create_iteration_info(resultt, subject_len);
        let sco_acc = scores.get_iteration_acc(0, 0, 0, PE_COUNT, false, itinf);
        let pre_acc = predc.get_iteration_acc(0, 0, 1, 1, itinf);

        let iai = create_data_vector(PE_COUNT, 0 as Score);
        let query_cpy = create_data_vector(PE_COUNT, 0 as Score);

        /// readQuery
        for pe in range(0, PE_COUNT){
            iai.write(pe, 4 as Score);
            query_cpy.write(pe, bitcast[&[1][SequenceElem]](querytt.data)(pe) as i32);
        }
        let que_acc = get_sequence_acc(|i|   if i >= PE_COUNT { 4 as SequenceElem } else { query_cpy.read(i) as u8 },
                                       |i,v| if i >= PE_COUNT { () } else { query_cpy.write(i, v as i32) });
        let sub_acc = get_sequence_acc(seq_reader(subjectt, subject_len), seq_writer(subjectt, subject_len));

        sco_acc.block_begin(query_len, que_acc);

        let mut bufoff = 0;
        let steps = subject_len + max(query_len, PE_COUNT) - 1;
        /// systolic0
        for i in range(0, steps) {
            if(i < subject_len) {
                let s = sub_acc.read(i);
                sco_acc.update_begin_line(0, i);
                iai.write(0, s as Score);
            }
            else {
                iai.write(0, 4 as Score);
                sco_acc.update_begin_line(1, i);
            }
            /// systolic1
            for pe in unroll_rev(PE_COUNT - 1, -1) {
                let _iai = iai.read(pe) as SequenceElem;
                fn @iai_reader() -> ReadSequenceFn{
                  |j| { if j >= pe { itinf.write_iai(_iai); _iai } else { itinf.write_iai(4 as SequenceElem); 4 as SequenceElem } }
                }
                @@(body)(pe, i, que_acc, get_sequence_acc(iai_reader(), |_,_|()),
                         sco_acc, pre_acc, scheme.relax);

                if(pe + 1 < PE_COUNT) {
                    sco_acc.update_write(pe);
                    iai.write(pe + 1, _iai as Score);
                }
            }
            if(i >= PE_COUNT - 1) {
                sco_acc.update_end_line(bufoff);
                bufoff = bufoff + 1;
            }
        }

        sco_acc.block_end();
    }
}

fn iteration_partitioned(half_size: Index, num_halfs: Index, block_width: Index, splits: Splits, max_part_height: Index) -> IterationFn{
    print_string("UNSUPPORTED: iteration_partitioned");

    undef[IterationFn]()
}

fn iteration_blockwise(block_width: Index, splits: Splits) -> IterationFn {
    print_string("UNSUPPORTED: iteration_blockwise");

    undef[IterationFn]()
}

fn iteration_tb(predc: MatrixS, splits: Splits, subject_length: Index, block_width: Index, body: fn (MatrixSAcc, Index, Index, Index, Index) -> ()) -> (){
    print_string("UNSUPPORTED: iteration_tb");

    undef[()]()
}


fn iteration_1d(length: Index, body: fn(Index) -> ()) -> (){
    print_string("UNSUPPORTED: iteration_1d");

    undef[()]()
}

fn iteration_matrix_1d(matrix: Matrix, length: Index, body: fn(Index, MatrixAcc) -> ()) -> (){
    print_string("UNSUPPORTED: iteration_matrix_1d");

    undef[()]()
}

fn iteration_matrix_s_1d(matrix: MatrixS, length: Index, body: fn(Index, MatrixSAcc) -> ()) -> (){
    print_string("UNSUPPORTED: iteration_matrix_s_1d");

    undef[()]()
}


fn iteration_vector_1d(vector: Vector, length: Index, body: fn(Index, VectorAcc) -> ()) -> (){
    print_string("UNSUPPORTED: iteration_vector_1d");

    undef[()]()
}
    

fn iteration_2_vectors_1d(vector_1: Vector, vector_2: Vector, length: Index, body: fn(Index, VectorAcc, VectorAcc) -> ()) -> (){
    print_string("UNSUPPORTED: iteration_2_vectors_1d");

    undef[()]()
}

fn iteration_reduction(vector: Vector, index_vec: Vector, score_vec: Vector, offset: Index, length: Index, body: fn(Score, Score) -> bool) -> (){
    print_string("UNSUPPORTED: iteration_reduction");

    undef[()]()
}
