
struct InitScoresAcc {
  read:  fn(Index) -> Score,
  write: fn(Index, Score) -> ()
}
fn @get_init_scores_acc(read: fn(Index) -> Score, write: fn(Index, Score) -> ()) -> InitScoresAcc{
    InitScoresAcc{
      read: read,
      write: write
    }
}
fn get_global_scoring_linmem(height: Index, width: Index, scheme: AlignmentScheme) -> Scoring{

    let score_matrix = create_scoring_matrix_linmem(height, width, scheme.init_scores);

    let get_score =     || get_vector_entry_cpu(score_matrix.get_last_column(), height - 1);
    let get_score_pos = || (height - 1, width - 1);

    create_scoring(score_matrix, get_score, get_score_pos)
}

fn get_semiglobal_scoring_linmem(height: Index, width: Index, scheme: AlignmentScheme) -> Scoring{
    
    let score_matrix = create_scoring_matrix_linmem(height, width, scheme.init_scores);

    let mut score = SCORE_MIN_VALUE;
    let mut pos   = (-1, -1);
    
    let find_score = || {
        
        let last_row    = score_matrix.get_last_row();
        let last_column = score_matrix.get_last_column();
        
        let (row_score, row_index) = reduce_max(last_row, -1, last_row.length + 1);

        if row_score > score {
            score = row_score;
            pos = (height - 1, row_index);
        }

        let (col_score, col_index) = reduce_max(last_column, -1, last_column.length + 1);

        if col_score > score {
            score = col_score;
            pos = (col_index, width - 1);
        }
    };

    let get_score = || {
        if score == SCORE_MIN_VALUE { find_score() }
        score
    };

    let get_score_pos = || {
        if score == SCORE_MIN_VALUE { find_score() }
        pos
    };

    create_scoring(score_matrix, get_score, get_score_pos)
}

fn get_local_scoring_linmem(height: Index, width: Index, scheme: AlignmentScheme) -> Scoring{
    
    let score_matrix = create_scoring_matrix_linmem(height, width, scheme.init_scores);
    
    let max_scores = create_vector(get_local_max_vector_size_device(width), get_padding_w(), alloc_device);
    let max_pos_i  = alloc_vector(max_scores, alloc_device);
    let max_pos_j  = alloc_vector(max_scores, alloc_device);

    for i, sco_acc in iteration_vector_1d(max_scores, max_scores.length){
        sco_acc.write(i, SCORE_MIN_VALUE);
    }

    let local_score_matrix = ScoringMatrix{
        get_iteration_acc:     get_local_linmem_iteration_acc_device(score_matrix, max_scores, max_pos_i, max_pos_j),
        get_matrix:            score_matrix.get_matrix,
        get_last_row:          score_matrix.get_last_row,
        get_last_column:       score_matrix.get_last_column,
        get_right_half_column: score_matrix.get_last_column,
        release:               score_matrix.release
     };

    let mut score = SCORE_MIN_VALUE;
    let mut pos   = (-1, -1);

    let find_score = || {   
        let (sco, index) = reduce_max(max_scores, 0, max_scores.length);

        score = sco;
        let pos_i = get_vector_entry_cpu(max_pos_i, index);
        let pos_j = get_vector_entry_cpu(max_pos_j, index);
        pos = (pos_i, pos_j);
    };

    let get_score = || {
        if score == SCORE_MIN_VALUE { find_score() }
        score
    };

    let get_score_pos = || {
        if score == SCORE_MIN_VALUE { find_score() }
        pos
    };

    let release = || {
        local_score_matrix.release();
        release(max_scores.buf);
        release(max_pos_i.buf);
        release(max_pos_j.buf);
    };

    Scoring{
        get_scoring_matrix:   || local_score_matrix,
        get_score:               get_score,
        get_score_pos:           get_score_pos,
        get_left_half_scores:    local_score_matrix.get_last_column,
        get_right_half_scores:   local_score_matrix.get_right_half_column,
        release:                 release
    }
}
fn create_scoring_matrix_linmem(height: Index, width: Index, init_scores: InitScoresAcc) -> ScoringMatrix{

    let column  = create_vector(height, get_padding_h(), alloc_device);
    let row     = create_vector(width, get_padding_w(), alloc_device);
    let corners = create_vector(round_up_div(width, BLOCK_WIDTH) - 1, get_padding_w(), alloc_device);

    for i, col_acc in iteration_vector_1d(column, column.length + 1){
        if i == 0 {
            col_acc.write(-1, init_scores.read(width - 1));
        } else {
            col_acc.write(i-1, init_scores.read(i-1));
        }
    }

    for i, row_acc in iteration_vector_1d(row, row.length + 1){
        if i == 0 {
            row_acc.write(-1, init_scores.read(height - 1)); 
        } else {
            row_acc.write(i-1, init_scores.read(i-1));
        }
    }

    for i, cor_acc in iteration_vector_1d(corners, corners.length + 1){
        cor_acc.write(i-1, init_scores.read(i * BLOCK_WIDTH - 1));
    }

    let release = || -> () {
        release(column.buf);
        release(row.buf);
        release(corners.buf);
    };

    ScoringMatrix{
        get_iteration_acc:        get_linmem_iteration_acc_device(column, row, corners),
        get_matrix:            || create_matrix(0, 0, 0, 0, alloc_device), //not supported with linmem matrix
        get_last_row:          || row,
        get_last_column:       || column,
        get_right_half_column: || column,
        release:                  release    
    }
}

fn get_linmem_iteration_acc_device(column: Vector, row: Vector, corners: Vector) -> fn(Index, Index, Index, Index, bool, IterationInfo) -> ScoringMatrixAcc{

    |offset_i, offset_j, height, width, _, it| -> ScoringMatrixAcc{

        let tid = it.tid_x;
        let block_j = offset_j / BLOCK_WIDTH;
       
        let lines = reserve_shared[Score]((BLOCK_WIDTH + 1) * 3);
        
        let lin_acc = get_rotation_acc(read_matrix_shared(lines), write_matrix_shared(lines), BLOCK_WIDTH);

        let col_acc = get_vector_acc_offset(read_vector(column), write_vector(column), offset_i);
        let row_acc = get_vector_acc_offset(read_vector(row), write_vector(row), offset_j);
        let cor_acc = get_vector_acc(read_vector(corners), write_vector(corners));

        lin_acc.write_lower(tid, row_acc.read(tid));
        lin_acc.write_middle(tid,row_acc.read(tid));
        lin_acc.write_upper(tid, row_acc.read(tid));

        if tid == 1 {
            //write corner value to position -1
            lin_acc.write_middle(-1, cor_acc.read(block_j - 1));
            //update corner value
            cor_acc.write(block_j - 1, col_acc.read(BLOCK_HEIGHT - 1));
        }

        ScoringMatrixAcc{
            read_no_gap: |_, j| lin_acc.read_middle(j - 1),
            read_gap_q:  |_, j| lin_acc.read_lower(j - 1),
            read_gap_s:  |_, j| lin_acc.read_lower(j),
            write:       |i, j, score| {
                lin_acc.write_upper(j, score);
                if i == height - 1 { row_acc.write(j, score); }
                if j == width - 1 { col_acc.write(i, score); }

            },
            update_begin_line: |i,_| {
                if tid == 0 && i < BLOCK_HEIGHT { lin_acc.write_lower(-1, col_acc.read(i)); }
            },
            update_end_line: |_| {
                lin_acc.rotate(); 
            },
            block_begin: |_,_|(),
            block_end: || {}
        }
    }
}

fn get_local_max_vector_size_device(matrix_width: Index) -> Index { matrix_width }

fn get_local_linmem_iteration_acc_device(score_matrix: ScoringMatrix, max_scores: Vector, max_pos_i: Vector, max_pos_j: Vector) -> fn(Index, Index, Index, Index, bool, IterationInfo) -> ScoringMatrixAcc{

    |offset_i, offset_j, height, width, is_left_half, it| {
        
        let mat_acc = score_matrix.get_iteration_acc(offset_i, offset_j, height, width, is_left_half, it);

        let mut max_score_thread = SCORE_MIN_VALUE;
        let mut max_pos_thread   = (0, 0);

        let write = |i, j, score| {
            mat_acc.write(i, j, score);
            if i < height && score > max_score_thread {
                max_score_thread = score;
                max_pos_thread = (i, j);
            }
        };
    
        let block_end = || {
        
            mat_acc.block_end();

            let max_sco_acc   = get_vector_acc(read_vector(max_scores), write_vector(max_scores));
            let max_pos_i_acc = get_vector_acc(read_vector(max_pos_i),  write_vector(max_pos_i) );
            let max_pos_j_acc = get_vector_acc(read_vector(max_pos_j),  write_vector(max_pos_j) );

            let index = offset_j + it.tid_x;
            
            let prev_max = max_sco_acc.read(index);
            
            if max_score_thread > prev_max {
                max_sco_acc.write(index, max_score_thread);
                max_pos_i_acc.write(index, max_pos_thread(0) + offset_i);
                max_pos_j_acc.write(index, max_pos_thread(1) + offset_j);
            }
        };

        ScoringMatrixAcc{
            read_no_gap:       mat_acc.read_no_gap,
            read_gap_q:        mat_acc.read_gap_q,
            read_gap_s:        mat_acc.read_gap_s,
            write:             write,
            update_begin_line: mat_acc.update_begin_line,
            update_end_line:   mat_acc.update_end_line,
            block_begin:       |_,_| (),
            block_end:         block_end
        }
    }
}

fn get_iteration_acc_hb_device(column_left: Vector, column_right: Vector, row: Vector, corners: Vector, block_width: Index) -> fn(Index, Index, Index, Index, bool, IterationInfo) -> ScoringMatrixAcc{

    |offset_i, offset_j, height, width, is_left_half, it| -> ScoringMatrixAcc{

        let tid = it.tid_x;
        let block_j = offset_j / block_width;

        let column = if is_left_half { column_left } else { column_right };    
       
        let lines = reserve_shared[Score]((BLOCK_WIDTH + 1) * 3);
        
        let lin_acc = get_rotation_acc(read_matrix_shared(lines), write_matrix_shared(lines), BLOCK_WIDTH);

        let col_acc = get_vector_acc_offset(read_vector(column), write_vector(column), offset_i);
        let row_acc = get_vector_acc_offset(read_vector(row), write_vector(row), offset_j);
        let cor_acc = get_vector_acc(read_vector(corners), write_vector(corners));
        
        lin_acc.write_lower(tid, row_acc.read(tid));
        lin_acc.write_middle(tid,row_acc.read(tid));
        lin_acc.write_upper(tid, row_acc.read(tid));

        if tid == 1 {
            //write corner value to position -1
            lin_acc.write_middle(-1, cor_acc.read(block_j - 1));
            //update corner value
            cor_acc.write(block_j - 1, col_acc.read(BLOCK_HEIGHT - 1));
        }

        ScoringMatrixAcc{
            read_no_gap: |_, j| lin_acc.read_middle(j - 1),
            read_gap_q:  |_, j| lin_acc.read_lower(j - 1),
            read_gap_s:  |_, j| lin_acc.read_lower(j),
            write:       |i, j, score| {
                lin_acc.write_upper(j, score);
                if i == height - 1 { row_acc.write(j, score); }
                if j == width - 1 { col_acc.write(i, score); }

            },
            update_begin_line: |i,_| {
                if tid == 0 && i < BLOCK_HEIGHT { lin_acc.write_lower(-1, col_acc.read(i)); }
            },
            update_end_line: |_| {
                lin_acc.rotate(); 
            },
            block_begin: |_,_| (),
            block_end: || {}
        }
    }
}

fn get_iteration_acc_tb_device(block_width: Index, init_scores: InitScoresAcc) -> fn(Index, Index, Index, Index, bool, IterationInfo) -> ScoringMatrixAcc{

    |offset_i, offset_j, height, width, is_left_half, it| -> ScoringMatrixAcc{

        let tid = it.tid_x;     
       
        let lines = reserve_shared[Score]((BLOCK_WIDTH + 1) * 3);
        
        let lin_acc = get_rotation_acc(read_matrix_shared(lines), write_matrix_shared(lines), block_width);

        lin_acc.write_lower(tid, init_scores.read(tid));
        lin_acc.write_middle(tid, init_scores.read(tid));
        lin_acc.write_upper(tid, init_scores.read(tid));

        if tid == 1 {
            lin_acc.write_middle(-1, init_scores.read(-1));
        }

        ScoringMatrixAcc{
            read_no_gap: |_, j| lin_acc.read_middle(j - 1),
            read_gap_q:  |_, j| lin_acc.read_lower(j - 1),
            read_gap_s:  |_, j| lin_acc.read_lower(j),
            write:       |i, j, score| lin_acc.write_upper(j, score),

            update_begin_line: |i,_| {
                if tid == 0 && i < height { lin_acc.write_lower(-1, init_scores.read(i)); }
            },
            update_end_line: |_| {
                lin_acc.rotate(); 
            },
            block_begin: |_,_| (),
            block_end: || {}
        }
    }
}

